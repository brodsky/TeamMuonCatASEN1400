//this is code for the second geiger counter. It should be on pins 5 and 7
int counter2SignPin = 5; 
int counter2NoisePin = 7; 


const double alpha = 53.032; // cpm = uSv x alpha

int counter2Index = 0; //Number of loops
char counter2Msg[256] = ""; //Message buffer for serial output

int counter2SignCount = 0; //Counter for Radiation Pulse
int counter2NoiseCount = 0; //Counter for Noise Pulse

int counter2SignOn = 0; //Lock flag for Radiation Pulse
int counter2NoiseOn = 0; //Lock flag for Noise Puls

double counter2Cpm = 0; //Count rate [cpm] of current
double counter2CpmHistory[200]; //History of count rates
int counter2CpmIndex = 0; //Position of current count rate on cpmHistory[]
int counter2CpmIndexPrev = 0; //Flag to prevent duplicative counting

//Timing Settings for Loop Interval
int counter2PrevTime = 0;
int counter2CurrTime = 0;

int counter2TotalSec = 0; //Elapsed time of measurement [sec]
int counter2TotalHour = 0; //Elapsed time of measurement [hour]

//Time settings for CPM calcuaration
int counter2CpmTimeMSec = 0;
int counter2CpmTimeSec = 0;
int counter2CpmTimeMin = 0;

//String buffers of float values for serial output
char counter2CpmBuff[20];
char counter2uSvBuff[20];
char counter2uSvdBuff[20];

void setup()
{
  //Serial setup
  //9600bps
  Serial.begin(9600);

  //PIN setting for Radiation Pulse
  pinMode(counter2SignPin, INPUT);
  digitalWrite(counter2SignPin, HIGH);

  //PIN setting for Noise Pulse
  pinMode(counter2NoisePin, INPUT);
  digitalWrite(counter2NoisePin, HIGH);

  //CSV-formatting for serial output (substitute , for _)
  Serial.println("sec[s],C2count,C2cpm,C2uSv/h,C2uSv/hError");

  //Initialize cpmHistory[]
  for (int i = 0; i < 200; i++ )
  {
    counter2CpmHistory[i] = 0;
  }

  //Get start time of a loop
  counter2PrevTime = millis();
}

void loop()
{
  // Raw data of Radiation Pulse: Not-detected -> High, Detected -> Low
  int counter2Sign = digitalRead(counter2SignPin);

  // Raw data of Noise Pulse: Not-detected -> Low, Detected -> High
  int counter2Noise = digitalRead(counter2NoisePin);

  //Radiation Pulse normally keeps low for about 100[usec]
  if (counter2Sign == 0 && counter2SignOn == 0){ 
    counter2SignOn = 1;
    counter2SignCount++;
  } 
  else if (counter2Sign == 1 && counter2SignOn == 1) {
    counter2SignOn = 0;
  }

  //Noise Pulse normally keeps high for about 100[usec]
  if (counter2Noise == 1 && counter2NoiseOn == 0)
  { 
    counter2NoiseOn = 1;
    counter2NoiseCount++;
  } else if (counter2Noise == 0 && counter2NoiseOn == 1) {
    counter2NoiseOn = 0;
  }

  //Output readings to serial port, after 10000 loops
  if (counter2Index == 10000) 
  {
    //Get current time
    counter2CurrTime = millis();

    //No noise detected in 10000 loops
    if (counter2NoiseCount == 0)
    {
      //Shift an array for counting log for each 6 sec.
      if ( counter2TotalSec % 6 == 0 && counter2CpmIndexPrev != counter2TotalSec)
      {
        counter2CpmIndexPrev = counter2TotalSec;
        counter2CpmIndex++;

        if (counter2CpmIndex >= 200)
        {
          counter2CpmIndex = 0;
        }

        if (counter2CpmHistory[counter2CpmIndex] > 0)
        {
          counter2Cpm -= counter2CpmHistory[counter2CpmIndex];
        }
        counter2CpmHistory[counter2CpmIndex] = 0;
      }

      //Store count log
      counter2CpmHistory[counter2CpmIndex] += counter2SignCount;
      //Add number of counts
      counter2Cpm += counter2SignCount;

      //Get ready time for 10000 loops
      counter2CpmTimeMSec += abs(counter2CurrTime - counter2PrevTime);
      //Transform from msec. to sec
      if (counter2CpmTimeMSec >= 1000){
        counter2CpmTimeMSec -= 1000;
        //Add measurement time to calcurate cpm readings (max=20min.)
        if ( counter2CpmTimeSec >= 20 * 60 ){
          counter2CpmTimeSec = 20 * 60;
        } 
        else {
          counter2CpmTimeSec++;
        }

        //Total measurement time
        counter2TotalSec++;
        
        //Transform from sec. to hour. (to prevent overflow)
        //if (counter2TotalSec >= 3600)
//        {
//          counter2TotalSec -= 3600;
//          counter2TotalHour++;
//        }
      }

      //Elapsed time of measurement (max=20min.)
      double min = counter2CpmTimeSec / 60.0;
      if (min != 0)
      {
        //Calculate cpm, uSv/h and error of uSv/h
        dtostrf(counter2Cpm / min, -1, 3, counter2CpmBuff);
        dtostrf(counter2Cpm / min / alpha, -1, 3, counter2uSvBuff);
        dtostrf(sqrt(counter2Cpm) / min / alpha, -1, 3, counter2uSvdBuff);
      } else {
        //Devision by zero
        dtostrf(0, -1, 3, counter2CpmBuff);
        dtostrf(0, -1, 3, counter2uSvBuff);
        dtostrf(0, -1, 3, counter2uSvdBuff);
      }

      
      sprintf(counter2Msg, "%d.%03d,%d,%s,%s,%s",counter2TotalSec,counter2CpmTimeMSec,counter2SignCount,counter2CpmBuff,counter2uSvBuff,counter2uSvdBuff);

      
      Serial.println(counter2Msg);

    }

    //Initialization for next 10000 loops
    counter2PrevTime = counter2CurrTime;
    counter2SignCount = 0;
    counter2NoiseCount = 0;
    counter2Index = 0;
  }
  counter2Index++;
}

